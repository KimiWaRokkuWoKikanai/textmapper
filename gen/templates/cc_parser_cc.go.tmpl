{{ template "header" . -}}
{{block "parserIncludes" . -}}
#include "parser.h"

#include <cstdint>
#include <string>

#include "lexer.h"
#include "absl/strings/str_format.h"
{{end}}
namespace {{.Options.Namespace}} {
{{block "onBeforeParser" .}}{{end -}}
{{template "parserTables" . -}}
{{template "lalr" . -}}
{{template "gotoState" . -}}
{{template "reportIgnoredToken" . -}}
{{- block "onAfterParser" .}}{{end}}
}  // namespace {{.Options.Namespace}}
{{/**/}}

{{- define "parserTables" -}}
constexpr inline absl::string_view tmNonterminals[] = {
{{- range .Parser.Nonterms}}
	"{{.Name}}",
{{- end}}
};
constexpr size_t tmNonterminalsLen =
    sizeof(tmNonterminals) / sizeof(tmNonterminals[0]);

std::string symbolName(int32_t sym) {
  if (sym == noToken) {
    return "<no-token>";
  }
  if (sym >= 0 && sym < static_cast<int32_t>(Token::NumTokens)) {
    return std::string(tokenStr[sym]);
  }
  if (sym >= static_cast<int32_t>(Token::NumTokens) &&
      sym - static_cast<int32_t>(Token::NumTokens) < tmNonterminalsLen) {
    return std::string(
        tmNonterminals[sym - static_cast<int32_t>(Token::NumTokens)]);
  }
  return absl::StrFormat("nonterminal(%d)", sym);
}

constexpr int32_t tmAction[] = {
{{- int_array .Parser.Tables.Action "\t" 79 -}}
};
{{- if .Parser.Tables.Lalr}}

constexpr int32_t tmLalr[] = {
{{- int_array .Parser.Tables.Lalr "\t" 79 -}}
};
{{- end}}

constexpr int32_t tmGoto[] = {
{{- int_array .Parser.Tables.Goto "\t" 79 -}}
};

{{$stateType := bits_per_element .Parser.Tables.FromTo -}}
constexpr int{{$stateType}}_t tmFromTo[] = {
{{- int_array .Parser.Tables.FromTo "\t" 79 -}}
};

constexpr int{{bits_per_element .Parser.Tables.RuleLen}}_t tmRuleLen[] = {
{{- int_array .Parser.Tables.RuleLen "\t" 79 -}}
};

constexpr int32_t tmRuleSymbol[] = {
{{- int_array .Parser.Tables.RuleSymbol "\t" 79 -}}
};

{{- if .Parser.UsesFlags}}

constexpr uint32_t tmRuleType[] = {
{{- range .Parser.Rules}}
{{- if ne .Type -1 }}
{{- $val := index $.Parser.Types.RangeTypes .Type }}
	{{if not (is_file_node $val.Name)}}uint32(NodeType::{{$val.Name}}){{if .Flags}} + uint32({{range $index, $flag := .Flags}}{{if ne $index 0}} | {{end}}NodeFlags::{{$flag}}{{end}})<<16{{end}}{{else}}0{{end}}, // {{$.RuleString .}}
{{- else }}
	0, // {{$.RuleString .}}
{{- end}}
{{- end}}
}
{{- else }}

constexpr NodeType tmRuleType[] = {
{{- range .Parser.Rules}}
{{- if ne .Type -1 }}
{{- $val := index $.Parser.Types.RangeTypes .Type }}
	NodeType::{{if not (is_file_node $val.Name)}}{{$val.Name}}{{else}}NoType{{end}}, // {{$.RuleString .}}
{{- else }}
	NodeType::NoType, // {{$.RuleString .}}
{{- end}}
{{- end}}
};
{{- end }}

{{- range .Sets}}

// {{.Expr}} = {{.ValueString $}}
[[maybe_unused]] constexpr int32_t {{.Name}}[] = {
{{- if gt (len .Terminals) 0 -}}
{{- int_array .Terminals "\t" 79 -}}
{{- end -}}
};
{{- end}}

{{end}}


{{- define "reportIgnoredToken" -}}
{{ if .ReportTokens true -}}
void Parser::reportIgnoredToken(symbol sym) {
{{ block "onBeforeIgnore" .}}{{end -}}
{{/**/}}  NodeType t;
{{- if .Lexer.UsesFlags}}
	var flags NodeFlags
{{- end}}
  switch (Token(sym.symbol)) {
{{- range .Lexer.MappedTokens}}
{{- $sym := index $.Syms .Token}}
{{- if or $sym.Space (eq $sym.Name "invalid_token") }}
	case Token::{{$sym.ID}}:
		t = NodeType::{{.Name}};
{{- if .Flags }}
		flags = {{range $index, $flag := .Flags}}{{if ne $index 0}} | {{end}}NodeFlags::{{$flag}}{{end}}
{{- end}}
    break;
{{- end}}
{{- end}}
	default:
		return;
  }
  if (debugSyntax) {
    LOG(INFO) << "ignored: " << Token(sym.symbol) << " as " << t;
  }
  listener_(t, {{if .Parser.UsesFlags}}{{if .Lexer.UsesFlags}}flags{{else}}0{{end}}, {{end}}sym.offset, sym.endoffset);
}

{{ end -}}
{{ end -}}

{{ define "lalr" -}}
{{ if .Parser.Tables.Lalr -}}
int32_t lalr(int32_t action, int32_t next) {
  int32_t a = -action - 3;
  for (; tmLalr[a] >= 0; a += 2) {
    if (tmLalr[a] == next) {
      break;
    }
  }
  return tmLalr[a + 1];
}

{{end -}}
{{end -}}

{{ define "gotoState" -}}
{{$stateType := bits_per_element .Parser.Tables.FromTo -}}
int{{$stateType}}_t gotoState(int{{$stateType}}_t state, int32_t symbol) {
  int32_t min = tmGoto[symbol];
  int32_t max = tmGoto[symbol + 1];

  if (max - min < 32) {
    for (auto i = min; i < max; i += 2) {
      if (tmFromTo[i] == state) {
        return tmFromTo[i + 1];
      }
    }
  } else {
    while (min < max) {
      int32_t e = ((min + max) / 2) & ~static_cast<int32_t>(1);
      int8_t i = tmFromTo[e];
      if (i == state) {
        return tmFromTo[e + 1];
      } else if (i < state) {
        min = e + 2;
      } else {
        max = e;
      }
    }
  }
  return -1;
}

{{ end -}}
