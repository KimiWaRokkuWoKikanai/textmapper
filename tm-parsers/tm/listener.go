// generated by Textmapper; DO NOT EDIT

package tm

import (
	"fmt"
)

type NodeType int

type Listener func(t NodeType, offset, endoffset int)

const (
	NoType         NodeType = iota
	AnnotationImpl          // name=Identifier Expression?
	Annotations             // (Annotation)+
	ArgumentFalse           // name=ParamRef
	ArgumentTrue            // name=ParamRef
	ArgumentVal             // name=ParamRef val=ParamValue?
	Array                   // (Expression)*
	Assoc
	BooleanLiteral
	ClassType // Implements?
	Command
	DirectiveAssert    // Empty? NonEmpty? RhsSet
	DirectiveBrackets  // opening=Symref closing=Symref
	DirectiveInput     // inputRefs=(Inputref)+
	DirectiveInterface // ids=(Identifier)+
	DirectivePrio      // Assoc symbols=(Symref)+
	DirectiveSet       // name=Identifier RhsSet
	Empty
	ExclusiveStartConds // states=(LexerState)+
	File                // Header imports=(Import)* options=(Option)* SyntaxProblem? lexer=LexerSection? parser=ParserSection?
	Header              // name=Identifier target=Identifier?
	Identifier
	Implements          // (Symref)+
	Import              // alias=Identifier? path=StringLiteral
	InclusiveStartConds // states=(LexerState)+
	InlineParameter     // param_type=Identifier name=Identifier ParamValue?
	Inputref            // reference=Symref NoEoi?
	IntegerLiteral
	InterfaceType
	Lexeme // StartConditions? name=Identifier RawType? Pattern? priority=IntegerLiteral? attrs=LexemeAttrs? Command?
	LexemeAttribute
	LexemeAttrs        // LexemeAttribute
	LexerSection       // (LexerPart)+
	LexerState         // name=Identifier
	ListSeparator      // separator_=(Symref)+
	LookaheadPredicate // Not? Symref
	Name
	NamedPattern // name=Identifier Pattern
	NoEoi
	NonEmpty
	Nonterm       // Annotations? name=Identifier params=NontermParams? NontermType? ReportClause? (Rule0)+
	NontermParams // list=(NontermParam)+
	Not
	Option // key=Identifier value=Expression
	ParamModifier
	ParamRef // Identifier
	ParamType
	ParserSection // (GrammarPart)+
	Pattern
	Predicate      // PredicateExpression
	PredicateAnd   // left=PredicateExpression right=PredicateExpression
	PredicateEq    // ParamRef Literal
	PredicateNot   // ParamRef
	PredicateNotEq // ParamRef Literal
	PredicateOr    // left=PredicateExpression right=PredicateExpression
	RawType
	ReportAs             // Identifier
	ReportClause         // action=Identifier flags=(Identifier)* ReportAs?
	RhsAnnotated         // Annotations inner=RhsPart
	RhsAsLiteral         // inner=RhsPart Literal
	RhsAssignment        // id=Identifier inner=RhsPart
	RhsCast              // inner=RhsPart target=Symref
	RhsIgnored           // (Rule0)+
	RhsLookahead         // predicates=(LookaheadPredicate)+
	RhsNested            // (Rule0)+
	RhsOptional          // inner=RhsPart
	RhsPlusAssignment    // id=Identifier inner=RhsPart
	RhsPlusList          // ruleParts=(RhsPart)+ ListSeparator
	RhsPlusQuantifier    // inner=RhsPart
	RhsSet               // expr=SetExpression
	RhsStarList          // ruleParts=(RhsPart)+ ListSeparator
	RhsStarQuantifier    // inner=RhsPart
	RhsSuffix            // Name Symref
	RhsSymbol            // reference=Symref
	Rule                 // Predicate? (RhsPart)* RhsSuffix? ReportClause?
	SetAnd               // left=SetExpression right=SetExpression
	SetComplement        // inner=SetExpression
	SetCompound          // inner=SetExpression
	SetOr                // left=SetExpression right=SetExpression
	SetSymbol            // operator=Identifier? symbol=Symref
	StartConditions      // (Stateref)*
	StartConditionsScope // StartConditions (LexerPart)+
	StateMarker          // name=Identifier
	Stateref             // name=Identifier
	StringLiteral
	SubType    // reference=Symref
	Symref     // name=Identifier args=SymrefArgs?
	SymrefArgs // arg_list=(Argument)*
	SyntaxProblem
	TemplateParam // modifier=ParamModifier? ParamType name=Identifier ParamValue?
	VoidType
	InvalidToken
	MultilineComment
	Comment
	Templates
	NodeTypeMax
)

var nodeTypeStr = [...]string{
	"NONE",
	"AnnotationImpl",
	"Annotations",
	"ArgumentFalse",
	"ArgumentTrue",
	"ArgumentVal",
	"Array",
	"Assoc",
	"BooleanLiteral",
	"ClassType",
	"Command",
	"DirectiveAssert",
	"DirectiveBrackets",
	"DirectiveInput",
	"DirectiveInterface",
	"DirectivePrio",
	"DirectiveSet",
	"Empty",
	"ExclusiveStartConds",
	"File",
	"Header",
	"Identifier",
	"Implements",
	"Import",
	"InclusiveStartConds",
	"InlineParameter",
	"Inputref",
	"IntegerLiteral",
	"InterfaceType",
	"Lexeme",
	"LexemeAttribute",
	"LexemeAttrs",
	"LexerSection",
	"LexerState",
	"ListSeparator",
	"LookaheadPredicate",
	"Name",
	"NamedPattern",
	"NoEoi",
	"NonEmpty",
	"Nonterm",
	"NontermParams",
	"Not",
	"Option",
	"ParamModifier",
	"ParamRef",
	"ParamType",
	"ParserSection",
	"Pattern",
	"Predicate",
	"PredicateAnd",
	"PredicateEq",
	"PredicateNot",
	"PredicateNotEq",
	"PredicateOr",
	"RawType",
	"ReportAs",
	"ReportClause",
	"RhsAnnotated",
	"RhsAsLiteral",
	"RhsAssignment",
	"RhsCast",
	"RhsIgnored",
	"RhsLookahead",
	"RhsNested",
	"RhsOptional",
	"RhsPlusAssignment",
	"RhsPlusList",
	"RhsPlusQuantifier",
	"RhsSet",
	"RhsStarList",
	"RhsStarQuantifier",
	"RhsSuffix",
	"RhsSymbol",
	"Rule",
	"SetAnd",
	"SetComplement",
	"SetCompound",
	"SetOr",
	"SetSymbol",
	"StartConditions",
	"StartConditionsScope",
	"StateMarker",
	"Stateref",
	"StringLiteral",
	"SubType",
	"Symref",
	"SymrefArgs",
	"SyntaxProblem",
	"TemplateParam",
	"VoidType",
	"InvalidToken",
	"MultilineComment",
	"Comment",
	"Templates",
}

func (t NodeType) String() string {
	if t >= 0 && int(t) < len(nodeTypeStr) {
		return nodeTypeStr[t]
	}
	return fmt.Sprintf("node(%d)", t)
}

var Annotation = []NodeType{
	AnnotationImpl,
	SyntaxProblem,
}

var Argument = []NodeType{
	ArgumentFalse,
	ArgumentTrue,
	ArgumentVal,
}

var Expression = []NodeType{
	Array,
	BooleanLiteral,
	IntegerLiteral,
	StringLiteral,
	Symref,
	SyntaxProblem,
}

var GrammarPart = []NodeType{
	DirectiveAssert,
	DirectiveInput,
	DirectiveInterface,
	DirectivePrio,
	DirectiveSet,
	Nonterm,
	SyntaxProblem,
	TemplateParam,
}

var LexerPart = []NodeType{
	DirectiveBrackets,
	ExclusiveStartConds,
	InclusiveStartConds,
	Lexeme,
	NamedPattern,
	StartConditionsScope,
	SyntaxProblem,
}

var Literal = []NodeType{
	BooleanLiteral,
	IntegerLiteral,
	StringLiteral,
}

var NontermParam = []NodeType{
	InlineParameter,
	ParamRef,
}

var NontermType = []NodeType{
	ClassType,
	InterfaceType,
	RawType,
	SubType,
	VoidType,
}

var ParamValue = []NodeType{
	BooleanLiteral,
	IntegerLiteral,
	ParamRef,
	StringLiteral,
}

var PredicateExpression = []NodeType{
	ParamRef,
	PredicateAnd,
	PredicateEq,
	PredicateNot,
	PredicateNotEq,
	PredicateOr,
}

var RhsPart = []NodeType{
	Command,
	RhsAnnotated,
	RhsAsLiteral,
	RhsAssignment,
	RhsCast,
	RhsIgnored,
	RhsLookahead,
	RhsNested,
	RhsOptional,
	RhsPlusAssignment,
	RhsPlusList,
	RhsPlusQuantifier,
	RhsSet,
	RhsStarList,
	RhsStarQuantifier,
	RhsSymbol,
	StateMarker,
	SyntaxProblem,
}

var Rule0 = []NodeType{
	Rule,
	SyntaxProblem,
}

var SetExpression = []NodeType{
	SetAnd,
	SetComplement,
	SetCompound,
	SetOr,
	SetSymbol,
}
