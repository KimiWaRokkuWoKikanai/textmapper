// generated by Textmapper; DO NOT EDIT

#include "json_parser.h"

#include <cstdint>
#include <string>
#include <unordered_set>

#include "absl/strings/str_format.h"
#include "json_lexer.h"

namespace json {
std::unordered_set<int8_t> barStates = {
    1,
    3,
    21,
    28,
};

[[maybe_unused]] constexpr int8_t fooState = 26;

constexpr inline absl::string_view tmNonterminals[] = {
    "JSONText",
    "JSONValue",
    "JSONValue_A",
    "EmptyObject",
    "lookahead_EmptyObject",
    "JSONObject",
    "lookahead_notEmptyObject",
    "JSONMember",
    "JSONMemberList",
    "JSONArray",
    "JSONElementList",
    "JSONElementListopt",
};
constexpr size_t tmNonterminalsLen =
    sizeof(tmNonterminals) / sizeof(tmNonterminals[0]);

std::string symbolName(int32_t sym) {
  if (sym == noToken) {
    return "<no-token>";
  }
  if (sym >= 0 && sym < static_cast<int32_t>(Token::NumTokens)) {
    return std::string(tokenStr[sym]);
  }
  if (sym >= static_cast<int32_t>(Token::NumTokens) &&
      sym - static_cast<int32_t>(Token::NumTokens) < tmNonterminalsLen) {
    return std::string(
        tmNonterminals[sym - static_cast<int32_t>(Token::NumTokens)]);
  }
  return absl::StrFormat("nonterminal(%d)", sym);
}

constexpr int32_t tmDefGoto[] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

constexpr int32_t tmGoto[] = {
    57, 31, 3, 19, 35, 36, 48, 24, 41, 49, 59, 62,
};

constexpr int32_t tmDefAct[] = {
    20, -1, -1, -1, 17, 18, 10, 11, 12, 13, 0,  15, 14, -1, 16,
    -1, 28, -1, -1, -1, 19, -1, 27, 22, -1, 25, -1, 29, -1, 21,
    -1, 8,  9,  1,  2,  3,  4,  24, 6,  5,  7,  26, -1, -1, -1,
};

constexpr int32_t tmActionBase = -20;

constexpr int32_t tmAction[] = {
    -20, 14,  -1,  -2,  -20, -20, -20, -20, -20, -20, -20, -20, -20, 6,  -20,
    8,   -20, 0,   12,  50,  -20, 14,  -20, -20, 15,  -20, 20,  -20, 30, -20,
    22,  -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, 55, -20,
};

constexpr int32_t tmTableLen = 78;

constexpr int8_t tmTable[] = {
    32,  -17, -5, 31, 10, 30,  16, -23, -21, -6,  -7,  -22, -8,  -9,  -10, -11,
    32,  -24, -5, 42, 11, -30, 11, -31, 27,  -6,  -7,  -32, -8,  -9,  -10, -11,
    32,  -26, -5, 2,  2,  12,  2,  12,  11,  -33, -34, 25,  -35, -36, -37, 38,
    -38, 13,  14, 13, 14, -25, 41, -46, 2,   12,  43,  37,  26,  -26, 17,  2,
    39,  18,  0,  0,  0,  13,  14, 0,   0,   0,   0,   0,   13,  40,
};

constexpr int8_t tmCheck[] = {
    2,  2,  4,  5,  1,  5,  3,  7,  2,  11, 12, 3,  14, 15, 16, 17,
    2,  5,  4,  0,  1,  6,  3,  3,  21, 11, 12, 7,  14, 15, 16, 17,
    2,  11, 4,  0,  1,  1,  3,  3,  21, 11, 12, 19, 14, 15, 16, 28,
    18, 1,  1,  3,  3,  3,  30, 0,  21, 21, 1,  28, 19, 11, 3,  28,
    28, 3,  -1, -1, -1, 21, 21, -1, -1, -1, -1, -1, 28, 28,
};

constexpr int8_t tmRuleLen[] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 3, 0, 4, 3, 0, 3, 1, 3, 3, 1, 3, 1, 0, 0,
};

constexpr int32_t tmRuleSymbol[] = {
    20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22,
    22, 22, 23, 24, 25, 25, 26, 27, 28, 28, 29, 30, 30, 31, 31, 26,
};

constexpr NodeType tmRuleType[] = {
    NodeType::JSONText,     // JSONText : JSONValue_A
    NodeType::JSONValue,    // JSONValue : kw_null
    NodeType::JSONValue,    // JSONValue : 'true'
    NodeType::JSONValue,    // JSONValue : 'false'
    NodeType::JSONValue,    // JSONValue : 'B'
    NodeType::JSONValue,    // JSONValue : JSONObject
    NodeType::JSONValue,    // JSONValue : EmptyObject
    NodeType::JSONValue,    // JSONValue : JSONArray
    NodeType::JSONValue,    // JSONValue : JSONString
    NodeType::JSONValue,    // JSONValue : JSONNumber
    NodeType::JSONValue,    // JSONValue_A : kw_null
    NodeType::JSONValue,    // JSONValue_A : 'true'
    NodeType::JSONValue,    // JSONValue_A : 'false'
    NodeType::JSONValue,    // JSONValue_A : 'A'
    NodeType::JSONValue,    // JSONValue_A : JSONObject
    NodeType::JSONValue,    // JSONValue_A : EmptyObject
    NodeType::JSONValue,    // JSONValue_A : JSONArray
    NodeType::JSONValue,    // JSONValue_A : JSONString
    NodeType::JSONValue,    // JSONValue_A : JSONNumber
    NodeType::EmptyObject,  // EmptyObject : lookahead_EmptyObject '{' '}'
    NodeType::NoType,       // lookahead_EmptyObject :
    NodeType::JSONObject,   // JSONObject : lookahead_notEmptyObject '{'
                            // JSONMemberList '}'
    NodeType::JSONObject,   // JSONObject : lookahead_notEmptyObject '{' '}'
    NodeType::NoType,       // lookahead_notEmptyObject :
    NodeType::JSONMember,   // JSONMember : JSONString ':' JSONValue
    NodeType::NoType,       // JSONMemberList : JSONMember
    NodeType::NoType,     // JSONMemberList : JSONMemberList .foo ',' JSONMember
    NodeType::JSONArray,  // JSONArray : .bar '[' JSONElementListopt ']'
    NodeType::NoType,     // JSONElementList : JSONValue_A
    NodeType::NoType,     // JSONElementList : JSONElementList ',' JSONValue_A
    NodeType::NoType,     // JSONElementListopt : JSONElementList
    NodeType::NoType,     // JSONElementListopt :
};

// set(first JSONValue_A) = LBRACE, LBRACK, JSONSTRING, JSONNUMBER, KW_NULL,
// TRUE, FALSE, CHAR_A
[[maybe_unused]] constexpr int32_t Literals[] = {
    2, 4, 11, 12, 14, 15, 16, 17,
};

// set(follow error) =
[[maybe_unused]] constexpr int32_t afterErr[] = {};

int8_t gotoState(int8_t state, int32_t symbol) {
  if (symbol >= static_cast<int32_t>(Token::NumTokens)) {
    int32_t pos =
        tmGoto[symbol - static_cast<int32_t>(Token::NumTokens)] + state;
    if (pos >= 0 && pos < tmTableLen && tmCheck[pos] == state) {
      return tmTable[pos];
    }
    return tmDefGoto[symbol - static_cast<int32_t>(Token::NumTokens)];
  }

  // Shifting a token.
  int32_t action = tmAction[state];
  if (action == tmActionBase) {
    return -1;
  }
  int32_t pos = action + symbol;
  if (pos >= 0 && pos < tmTableLen && tmCheck[pos] == symbol) {
    action = tmTable[pos];
  } else {
    action = tmDefAct[state];
  }
  if (action < -1) {
    return -2 - action;
  }
  return -1;
}

ABSL_MUST_USE_RESULT int32_t lookaheadNext(Lexer& lexer) {
  Token tok;
restart:
  tok = lexer.Next();
  switch (tok) {
    case Token::MULTILINECOMMENT:
    case Token::INVALID_TOKEN:
      goto restart;
    default:
      break;
  }
  return static_cast<int32_t>(tok);
}

ABSL_MUST_USE_RESULT bool lookahead(Lexer& lexer_to_copy, int32_t next,
                                    int8_t start, int8_t end) {
  Lexer lexer = lexer_to_copy;

  std::vector<stackEntry> stack;
  stack.reserve(64);

  int8_t state = start;
  stack.push_back(stackEntry{.state = state});

  while (state != end) {
    int32_t action = tmAction[state];
    if (action > tmActionBase) {
      // Lookahead is needed.
      if (next == noToken) {
        next = lookaheadNext(lexer);
      }
      int32_t pos = action + next;
      if (pos >= 0 && pos < tmTableLen && tmCheck[pos] == next) {
        action = tmTable[pos];
      } else {
        action = tmDefAct[state];
      }
    } else {
      action = tmDefAct[state];
    }

    if (action >= 0) {
      // Reduce.
      int32_t rule = action;
      auto ln = static_cast<int32_t>(tmRuleLen[rule]);

      stackEntry entry;
      entry.sym.symbol = tmRuleSymbol[rule];
      stack.resize(stack.size() - ln);
      if (debugSyntax) {
        LOG(INFO) << "lookahead reduced to: " << symbolName(entry.sym.symbol);
      }
      state = gotoState(stack.back().state, entry.sym.symbol);
      entry.state = state;
      stack.push_back(std::move(entry));
    } else if (action < -1) {
      // Shift.
      state = -2 - action;
      stack.push_back(stackEntry{
          .sym = symbol{.symbol = next},
          .state = state,
      });
      if (debugSyntax) {
        LOG(INFO) << "lookahead shift: " << symbolName(next) << " ("
                  << lexer.Text() << ")";
      }
      if (state != -1 && next != eoiToken) {
        next = noToken;
      }
    }

    if (action == -1 || state == -1) {
      break;
    }
  }

  if (debugSyntax) {
    LOG(INFO) << "lookahead done: " << ((state == end) ? "true" : "false");
  }
  return state == end;
}

ABSL_MUST_USE_RESULT bool AtEmptyObject(Lexer& lexer, int32_t next) {
  if (debugSyntax) {
    LOG(INFO) << "lookahead EmptyObject; next: " << symbolName(next);
  }
  return lookahead(lexer, next, 0, 42);
}

void Parser::reportIgnoredToken(symbol sym) {
  NodeType t;
  switch (Token(sym.symbol)) {
    case Token::MULTILINECOMMENT:
      t = NodeType::MultiLineComment;
      break;
    case Token::INVALID_TOKEN:
      t = NodeType::InvalidToken;
      break;
    default:
      return;
  }
  if (debugSyntax) {
    LOG(INFO) << "ignored: " << Token(sym.symbol) << " as " << t;
  }
  listener_(t, sym.location);
}

void Parser::fetchNext(Lexer& lexer, std::vector<stackEntry>& stack) {
  Token tok;
restart:
  tok = lexer.Next();
  switch (tok) {
    case Token::MULTILINECOMMENT:
    case Token::INVALID_TOKEN:
      pending_symbols_.push_back(
          symbol{static_cast<int32_t>(tok), lexer.LastTokenLocation()});
      goto restart;
    default:
      break;
  }

  next_symbol_.symbol = static_cast<int32_t>(tok);
  next_symbol_.location = lexer.LastTokenLocation();
}

absl::Status Parser::applyRule(
    int32_t rule, stackEntry& lhs,
    [[maybe_unused]] absl::Span<const stackEntry> rhs, Lexer& lexer) {
  switch (rule) {
    case 0:  // JSONText : JSONValue_A
    {
      lhs.value.b = rhs[0].value.a;
    } break;
    case 3:  // JSONValue : 'false'
    {
      lhs.value.a = 5;
    } break;
    case 12:  // JSONValue_A : 'false'
    {
      lhs.value.a = 5;
    } break;
    case 19:  // EmptyObject : lookahead_EmptyObject '{' '}'
    {
      lhs.sym.location.begin = rhs[1].sym.location.begin;
    } break;
    case 21:  // JSONObject : lookahead_notEmptyObject '{' JSONMemberList '}'
    {
      lhs.sym.location.begin = rhs[1].sym.location.begin;
    } break;
    case 22:  // JSONObject : lookahead_notEmptyObject '{' '}'
    {
      lhs.sym.location.begin = rhs[1].sym.location.begin;
    } break;

    case 32:
      if (AtEmptyObject(lexer, next_symbol_.symbol)) {
        lhs.sym.symbol = 24; /* lookahead_EmptyObject */
      } else {
        lhs.sym.symbol = 26; /* lookahead_notEmptyObject */
      }
      return absl::OkStatus();
    default:
      break;
  }

  if (NodeType nt = tmRuleType[rule]; nt != NodeType::NoType) {
    listener_(nt, lhs.sym.location);
  }
  return absl::OkStatus();
}

absl::Status Parser::Parse(int8_t start, int8_t end, Lexer& lexer) {
  pending_symbols_.clear();
  int8_t state = start;

  std::vector<stackEntry> stack;
  stack.reserve(startStackSize);
  stack.push_back(stackEntry{.state = state});
  fetchNext(lexer, stack);

  while (state != end) {
    int32_t action = tmAction[state];
    if (action > tmActionBase) {
      // Lookahead is needed.
      if (next_symbol_.symbol == noToken) {
        fetchNext(lexer, stack);
      }
      int32_t pos = action + next_symbol_.symbol;
      if (pos >= 0 && pos < tmTableLen && tmCheck[pos] == next_symbol_.symbol) {
        action = tmTable[pos];
      } else {
        action = tmDefAct[state];
      }
    } else {
      action = tmDefAct[state];
    }

    if (action >= 0) {
      // Reduce.
      int32_t rule = action;
      int32_t ln = tmRuleLen[rule];
      stackEntry entry;
      entry.sym.symbol = tmRuleSymbol[rule];
      absl::Span<const stackEntry> rhs;

      if (ln == 0) {
        if (next_symbol_.symbol == noToken) {
          fetchNext(lexer, stack);
        }
        entry.sym.location = Lexer::Location(stack.back().sym.location.end,
                                             stack.back().sym.location.end);
        entry.value = stack.back().value;
      } else {
        rhs = absl::Span<const stackEntry>(&stack[0] + stack.size() - ln, ln);
        entry.sym.location = Lexer::Location(rhs.front().sym.location.begin,
                                             rhs.back().sym.location.end);
        entry.value = rhs.front().value;
      }
      absl::Status ret = applyRule(rule, entry, rhs, lexer);
      if (!ret.ok()) {
        return ret;
      }
      stack.resize(stack.size() - ln);
      if (debugSyntax) {
        LOG(INFO) << "reduced to: " << symbolName(entry.sym.symbol)
                  << " consuming " << ln << " symbols, range "
                  << entry.sym.location;
      }
      state = gotoState(stack.back().state, entry.sym.symbol);
      entry.state = state;
      stack.push_back(std::move(entry));
    } else if (action < -1) {
      // Shift.
      state = -2 - action;
      stack.push_back(stackEntry{
          .sym = next_symbol_,
          .state = state,
      });
      if (debugSyntax) {
        LOG(INFO) << "shift: " << symbolName(next_symbol_.symbol) << " ("
                  << lexer.Text() << ")";
      }
      if (!pending_symbols_.empty()) {
        for (const auto& tok : pending_symbols_) {
          reportIgnoredToken(tok);
        }
        pending_symbols_.clear();
      }
      if (next_symbol_.symbol != eoiToken) {
        switch (Token(next_symbol_.symbol)) {
          case Token::JSONSTRING:
            listener_(NodeType::JsonString, next_symbol_.location);
            break;
          default:
            break;
        }
        next_symbol_.symbol = noToken;
      }
    }
    if (action == -1 || state == -1) {
      break;
    }
  }

  if (state != end) {
    if (next_symbol_.symbol == noToken) {
      fetchNext(lexer, stack);
    }
    // TODO return a syntax error
    return absl::InvalidArgumentError(absl::StrFormat(
        "Syntax error: line %d: %s", lexer.LastTokenLine(), lexer.Text()));
  }
  return absl::OkStatus();
}

}  // namespace json
